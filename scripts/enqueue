#!/bin/bash

if [ "${SCRIPT_PATH}" == "" ]; then
    echo "This script should not be called directly! Please use mq.sh"
    exit -1
fi

# List of a bunch of signals that we will try and trap on. This is basically a
# 'if anything at all happens try and shut down our job cleanly' approach
SIGNALS="SIGINT SIGTERM SIGHUP SIGQUIT SIGKILL SIGSTOP SIGPIPE"

function SignalRemoveJob() {
    local system=$1
    local user=$2
    # First do fast cleanup that doesn't require any locks
    FastRemoveJob ${system} ${user}
    echo "Received signal. Finishing clean up, please be patient"
    # Now attempt to get the lock and do the rest of cleanup. But do so in a fast way
    if FastLockSystem ${system}; then
        RemoveJob ${system} ${user}
        UnlockSystem ${system}
    fi
    exit -1
}

function EnqueueUsage() {
    echo "$0 run -r|-i|-c <string> -l logfile -s system -f file1 -f file2 .. -f filen"
    echo
    echo "   Enqueues a new job and then waits for it to complete before returning."
    echo "   Jobs can include reservations due to synchronous nature."
    echo
    echo "   Output from the machine is generally collected and passed back to the"
    echo "   user both on stdout and in the form of an option logfile."
    echo
    echo "   Jobs can be canceled at any time with ^C, which will notify the server"
    echo "   if the job is running and remove the job from the queue."
    echo
    echo "   Returns 0 on success, nonzero if something went wrong"
    echo
    echo "Options:"
    echo
    echo " -r          Reserves the device. Will not reboot or run an image"
    echo " -c TEXT     Image is run until the specified regular completion text"
    echo " -l FILE     Optional location to write all the console output to"
    echo " -s TEXT     Specifies which machine this job is for"
    echo " -f FILE [+] Files to use as the job image"
    echo
}

function Enqueue() {
    # Parse the command line
    local file_count=0
    local logfile=""
    local interact=""
    local completion=""
    local files=""
    local system=""
    local file_prefix=""
    local user=$USER
    if [ "${user}" == "" ]; then
        echo "Attempted to user USER environment variable to construct a user name"
        echo "but received an empty string. Please set to your user name"
        exit -1
    fi
    while [ "$#" -ne 0 ]; do
        case "$1" in
            -l)
                shift
                logfile="$1"
            ;;
            -c)
                shift
                completion="$1"
                if [ "$interact" != "" ]; then
                    EnqueueUsage
                    exit -1
                fi
                interact="-c"
            ;;
            -r)
                interact="-r"
            ;;
            -f)
                shift
#                if ! [ -f "$1" ]; then
#                    echo "File \"$1\" either does not exist, or is not considered a valid file"
#                    exit -1
#                fi
                if [ "$files" != "" ]; then
                    files="$files "
                fi
                files="$files$1"
                (( file_count++ ))
            ;;
            -s)
                shift
                system="$1"
            ;;
            -p)
                shift
                file_prefix="$1"
            ;;
            --)
                break
            ;;
            *)
                echo "Unknown option $1"
                EnqueueUsage
                exit -1
            ;;
        esac
        shift
    done

    # Check that we got enough parameters
    if [ "$system" = "" ]; then
        EnqueueUsage
        exit -1
    fi
    if [ "$interact" = "" ]; then
        EnqueueUsage
        exit -1
    fi

    # Verify the requested system exists
    IsSystemValid "${system}"
    if [ $? -ne 0 ] ; then
        echo "System $system does not exist"
        exit -1
    fi

    # Check that the number of files specified is correct
    if [ "$interact" != "-r" ] ; then
        if ! SystemCorrectNumberOfFiles "${system}" "${file_count}"; then
            echo "Wrong number of files specified for system ${system}"
            exit -1
        fi
    fi

    echo "Acquring lock to enqueue for ${system}"

    # Grab the main lock for the system
    if ! LockSystem "${system}"; then
        echo "Failed to acquire system (${system}) lock. Assuming kill occured, nothing to clean up"
        exit -1
    fi

    echo "Seeing if ${user} already has a job for ${system}"

    # See if we have an outstanding lock or lock request for this system
    if JobExists "${system}" "${user}"; then
        echo "You already have a job queued or in progress for this system (${system})"
        UnlockSystem "${system}"
        exit -1
    fi

    # Add a job. But first setup a signal handler that will try and remove a running job
    echo "Attempting to add job for ${user} to ${system}"
    trap "SignalRemoveJob ${system} ${user}" ${SIGNALS}
    if ! AddJob "${system}" "${user}"; then
        echo "Failed to add job somehow. Removing locks and exiting"
        UnlockSystem "${system}"
        exit -1
    fi

    # Setup is done, release the lock
    UnlockSystem "${system}"
    echo "Released queue lock for ${system}"

    echo "Notifying bamboo to run ${system}"
    SystemNotifyBamboo ${system}

    echo "Waiting for permission to run..."
    # Now wait for the job
    if ! WaitJob "${system}" "${user}"; then
        # Assume ctrl+c, clean up ASAP. This does not require any locks
        FastRemoveJob "${system}" "${user}"
        # Now do the rest
        if ! LockSystem "${system}"; then
            echo "Failed to acquire system lock. Job may not have been cleaned up correctly"
            exit -1
        fi
        RemoveJob "${system}" "${user}"
        UnlockSystem "${system}"
        echo "Failed to wait for the chance to run job. Cleaned up and now exiting"
        exit -1
    fi

    echo "We are allowed to run"
    local ret=0

    if [ "${interact}" = "-r" ]; then
        echo "This is a reservation. You now own ${system} and"
        echo "can do what you want. Press ctrl+d or enter here when done"
        read line
    else
        # Run the image. 'files' is deliberately no in quotes so the multiple
        # files expands to multiple arguments
        SystemRunImage ${system} "${completion}" "${logfile}" $files
        ret=$?
    fi


    echo "All done. Cleaning up job for ${user} on ${system}"
    if ! LockSystem ${system}; then
        FastRemoveJob ${system} ${user}
        echo "Failed to acquire lock to cleanup job. Cleaning up what we can without a lock"
        exit -1
    fi

    RemoveJob ${system} ${user}
    UnlockSystem ${system}

    exit $ret

    # Setup the output pipe that will feed data from the console
    # to the user terminal
    local outpipe=$(OutPipe ${jobid})
    setsid bash -c "trap 'exit 0' $SIGNALS; while true; do cat \"$outpipe\"; done" &
    local outpid=$!

    # Setup a trap handler that will remove this job and notify the server if we try and quit
    # we will fiddle with this trap a bit for when it needs to attempt to tell the remote
    # server to shut down
    trap "CleanupJob ${jobid} ${outpid} 1 ${interact}" $SIGNALS

    # Hook up the pipe to feed input from user to console if required
    if [ "$interact" != "-c" ]; then
        # This cat will terminate at the same time as when the user does the ctrl+c to
        # terminate the script. so the ctrl+c is both terminating the cat and being caught
        # by our signal handler
        # Killing the cat session also causes an EOF to appear on the pipe
        # which will cause the remote server to realize the job is done and finish
        cat > $(InPipe ${jobid})
    fi
    # Wait on the completion semaphore.
    if ! lockfile -1 "$(JobLock ${jobid})"; then
        lockfile -1 "$(JobLock ${jobid})"
    fi

    # Our job is done so do not try and signal the remote
    trap "CleanupJob ${jobid} ${outpid} 0 ${interact}" $SIGNALS

    # Check if the signal handler cleaned up the job. This would only happen if it was queued
    # and hence we have no output to grab or anything
    if [ "${signal_did_cleanup}" = "1" ]; then
        echo "Job canceled while queued. Done"
        exit 0
    fi

    # Everything is cleaned up, no longer need the trap handler
    trap '' $SIGNALS

    # Should be complete
    echo "Job complete"

    # Grab the main lock
    Lock

    # Verify our job is complete
    if [ "$(JobStatus ${jobid})" != 'COMPLETE' ]; then
        echo "Job failed to complete or missing!"
        # Kill the output pipe
        kill -- -$outpid
        Unlock
        exit 1
    fi

    # Kill the output pipe
    kill -- -$outpid

    # Copy the output
    local source_log=$(JobOutput ${jobid})
    if ! [ -e "${source_log}" ]; then
        echo "No output found! Not outputting to ${logfile}"
    else
        if [ "${logfile}" = "" ]; then
            echo "No logfile specified. Discarding output"
        else
            echo "Copying output to \"$logfile\""
            scp "${source_log}" "${file_prefix}$logfile"
        fi
    fi
    # See if we can get an error code
    local result=$(JobError ${jobid})
    # Cleanup the job
    echo "Cleaning up job"
    RemoveJob ${jobid}

    # Release the lock and go home
    Unlock
    echo "Done (${result})"

    exit $result
}
