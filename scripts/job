#!/bin/bash

if [ "${SCRIPT_PATH}" == "" ]; then
    echo "This script should not be called directly! Please use mq.sh"
    exit -1
fi

# List of a bunch of signals that we will try and trap on. This is basically a
# 'if anything at all happens try and shut down our job cleanly' approach
SIGNALS="SIGINT SIGTERM SIGHUP SIGQUIT SIGKILL SIGSTOP SIGPIPE"

function JobWantLock() {
    local system=$1
    local user=$2
    echo "${BASE}/${system}/job_want_${user}.lock"
}

function JobCompleteLock() {
    local system=$1
    local user=$2
    echo "${BASE}/${system}/job_complete_${user}.lock"
}

# Makes a lock assuming that it doesn't exist
function MakeLock() {
    local lock=$1
    RemoteCommand lockfile -1 -r 1 "${lock}"
    if [ $? -eq 0 ]; then
        RemoteCommand chown -f :ertos_src "${lock}" 2>&1 > /dev/null
        return 0
    fi
    return -1
}

function RemoveLock() {
    local lock=$1
    RemoteCommand rm -f "${lock}"
}

function RemoveJob() {
    local system=$1
    local user=$2
    # Remove the two locks
    RemoveLock "$(JobWantLock ${system} ${user})"
    RemoveLock "$(JobCompleteLock ${system} ${user})"
    # Now remove from the queue
    RemoveFromQueue ${system} ${user}
}

function AddJob() {
    local system=$1
    local user=$2
    # Remove any existing lockfiles
    RemoveLock "$(JobWantLock ${system} ${user})"
    RemoveLock "$(JobCompleteLock ${system} ${user})"
    # Create the two lockfiles
    MakeLock "$(JobWantLock ${system} ${user})"
    if [ $? -ne 0 ]; then
        return -1
    fi
    MakeLock "$(JobCompleteLock ${system} ${user})"
    if [ $? -ne 0 ]; then
        RemoveLock "$(JobWantLock ${system} ${user})"
        return -1
    fi
    AddToQueue ${system} ${user}
}

function WaitJobComplete() {
    local system=$1
    local user=$2
    # Wait until the lockfile appears
    LockFileInteractive "$(JobCompleteLock ${system} ${user})"
}

function WaitJob() {
    local system=$1
    local user=$2
    # Wait until the lockfile appears
    LockFileInteractive "$(JobWantLock ${system} ${user})"
}

function LockExists() {
    local lock=$1
    RemoteCommand [ -e "${lock}" ]
    return $?
}

function JobExists() {
    local system=$1
    local user=$2
#    ReadQueue ${system} | grep -q "^${user}\$" || LockExists "$(JobWantLock ${system} ${user})" || LockExists "$(JobCompleteLock ${system} ${user})"
    ReadQueue ${system} | grep -q "^${user}\$"
    return $?
}

# This function operates WITHOUT holding the lock
# Attempts to clean up the bare minimum of a job such that
# it will not block other jobs from running
function FastRemoveJob() {
    local system=$1
    local user=$2
    RemoveLock "$(JobCompleteLock ${system} ${user})"
}
